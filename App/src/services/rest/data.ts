/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.9.0 (NJsonSchema v10.6.8.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';
import { AuthorizedApiBase, IConfig } from "./iconfig";

export class FakeClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(configuration: IConfig, baseUrl?: string, instance?: AxiosInstance) {

    super(configuration);

    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";

  }

  seed(cancelToken?: CancelToken | undefined): Promise<boolean> {
    let url_ = this.baseUrl + "/data/Fake/Seed";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        "Accept": "application/json"
      },
      cancelToken
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.instance.request(transformedOptions_);
    }).catch((_error: any) => {
      if (isAxiosError(_error) && _error.response) {
        return _error.response;
      } else {
        throw _error;
      }
    }).then((_response: AxiosResponse) => {
      return this.processSeed(_response);
    });
  }

  protected processSeed(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }
}

export class ValueClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(configuration: IConfig, baseUrl?: string, instance?: AxiosInstance) {

    super(configuration);

    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";

  }

  getLastValue(aquarium: string | null, datapoint: string | null, cancelToken?: CancelToken | undefined): Promise<ValueReturnModelSingle> {
    let url_ = this.baseUrl + "/data/Value/{Aquarium}/GetLastValue/{Datapoint}";
    if (aquarium === undefined || aquarium === null)
      throw new Error("The parameter 'aquarium' must be defined.");
    url_ = url_.replace("{Aquarium}", encodeURIComponent("" + aquarium));
    if (datapoint === undefined || datapoint === null)
      throw new Error("The parameter 'datapoint' must be defined.");
    url_ = url_.replace("{Datapoint}", encodeURIComponent("" + datapoint));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        "Accept": "application/json"
      },
      cancelToken
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.instance.request(transformedOptions_);
    }).catch((_error: any) => {
      if (isAxiosError(_error) && _error.response) {
        return _error.response;
      } else {
        throw _error;
      }
    }).then((_response: AxiosResponse) => {
      return this.processGetLastValue(_response);
    });
  }

  protected processGetLastValue(response: AxiosResponse): Promise<ValueReturnModelSingle> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ValueReturnModelSingle.fromJS(resultData200);
      return Promise.resolve<ValueReturnModelSingle>(result200);

    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException("A server side error occurred.", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ValueReturnModelSingle>(null as any);
  }

  getLastValues(aquarium: string | null, cancelToken?: CancelToken | undefined): Promise<ValueReturnModelSingle[]> {
    let url_ = this.baseUrl + "/data/Value/{Aquarium}/GetLastValues";
    if (aquarium === undefined || aquarium === null)
      throw new Error("The parameter 'aquarium' must be defined.");
    url_ = url_.replace("{Aquarium}", encodeURIComponent("" + aquarium));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        "Accept": "application/json"
      },
      cancelToken
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.instance.request(transformedOptions_);
    }).catch((_error: any) => {
      if (isAxiosError(_error) && _error.response) {
        return _error.response;
      } else {
        throw _error;
      }
    }).then((_response: AxiosResponse) => {
      return this.processGetLastValues(_response);
    });
  }

  protected processGetLastValues(response: AxiosResponse): Promise<ValueReturnModelSingle[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200)
          result200!.push(ValueReturnModelSingle.fromJS(item));
      }
      else {
        result200 = <any>null;
      }
      return Promise.resolve<ValueReturnModelSingle[]>(result200);

    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException("A server side error occurred.", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ValueReturnModelSingle[]>(null as any);
  }
}

export class DeviceClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(configuration: IConfig, baseUrl?: string, instance?: AxiosInstance) {

    super(configuration);

    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";

  }

  get(aquarium: string | null, cancelToken?: CancelToken | undefined): Promise<Device[]> {
    let url_ = this.baseUrl + "/data/Device/{Aquarium}/Devices";
    if (aquarium === undefined || aquarium === null)
      throw new Error("The parameter 'aquarium' must be defined.");
    url_ = url_.replace("{Aquarium}", encodeURIComponent("" + aquarium));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        "Accept": "application/json"
      },
      cancelToken
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.instance.request(transformedOptions_);
    }).catch((_error: any) => {
      if (isAxiosError(_error) && _error.response) {
        return _error.response;
      } else {
        throw _error;
      }
    }).then((_response: AxiosResponse) => {
      return this.processGet(_response);
    });
  }

  protected processGet(response: AxiosResponse): Promise<Device[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200)
          result200!.push(Device.fromJS(item));
      }
      else {
        result200 = <any>null;
      }
      return Promise.resolve<Device[]>(result200);

    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = ProblemDetails.fromJS(resultData401);
      return throwException("A server side error occurred.", status, _responseText, _headers, result401);

    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Device[]>(null as any);
  }

  modbusDevicePOST(aquarium: string | null, modbus: ModbusDevice, cancelToken?: CancelToken | undefined): Promise<ItemResponseModelOfModbusDevice> {
    let url_ = this.baseUrl + "/data/Device/{Aquarium}/ModbusDevice";
    if (aquarium === undefined || aquarium === null)
      throw new Error("The parameter 'aquarium' must be defined.");
    url_ = url_.replace("{Aquarium}", encodeURIComponent("" + aquarium));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(modbus);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      cancelToken
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.instance.request(transformedOptions_);
    }).catch((_error: any) => {
      if (isAxiosError(_error) && _error.response) {
        return _error.response;
      } else {
        throw _error;
      }
    }).then((_response: AxiosResponse) => {
      return this.processModbusDevicePOST(_response);
    });
  }

  protected processModbusDevicePOST(response: AxiosResponse): Promise<ItemResponseModelOfModbusDevice> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ItemResponseModelOfModbusDevice.fromJS(resultData200);
      return Promise.resolve<ItemResponseModelOfModbusDevice>(result200);

    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException("A server side error occurred.", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ItemResponseModelOfModbusDevice>(null as any);
  }

  mQTTDevicePOST(aquarium: string | null, modbus: MQTTDevice, cancelToken?: CancelToken | undefined): Promise<ItemResponseModelOfMQTTDevice> {
    let url_ = this.baseUrl + "/data/Device/{Aquarium}/MQTTDevice";
    if (aquarium === undefined || aquarium === null)
      throw new Error("The parameter 'aquarium' must be defined.");
    url_ = url_.replace("{Aquarium}", encodeURIComponent("" + aquarium));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(modbus);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      cancelToken
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.instance.request(transformedOptions_);
    }).catch((_error: any) => {
      if (isAxiosError(_error) && _error.response) {
        return _error.response;
      } else {
        throw _error;
      }
    }).then((_response: AxiosResponse) => {
      return this.processMQTTDevicePOST(_response);
    });
  }

  protected processMQTTDevicePOST(response: AxiosResponse): Promise<ItemResponseModelOfMQTTDevice> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ItemResponseModelOfMQTTDevice.fromJS(resultData200);
      return Promise.resolve<ItemResponseModelOfMQTTDevice>(result200);

    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException("A server side error occurred.", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ItemResponseModelOfMQTTDevice>(null as any);
  }

  modbusDevicePUT(aquarium: string | null, iD: string | null, modbus: ModbusDevice, cancelToken?: CancelToken | undefined): Promise<ItemResponseModelOfDevice> {
    let url_ = this.baseUrl + "/data/Device/{Aquarium}/ModbusDevice/{ID}";
    if (aquarium === undefined || aquarium === null)
      throw new Error("The parameter 'aquarium' must be defined.");
    url_ = url_.replace("{Aquarium}", encodeURIComponent("" + aquarium));
    if (iD === undefined || iD === null)
      throw new Error("The parameter 'iD' must be defined.");
    url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(modbus);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      cancelToken
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.instance.request(transformedOptions_);
    }).catch((_error: any) => {
      if (isAxiosError(_error) && _error.response) {
        return _error.response;
      } else {
        throw _error;
      }
    }).then((_response: AxiosResponse) => {
      return this.processModbusDevicePUT(_response);
    });
  }

  protected processModbusDevicePUT(response: AxiosResponse): Promise<ItemResponseModelOfDevice> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ItemResponseModelOfDevice.fromJS(resultData200);
      return Promise.resolve<ItemResponseModelOfDevice>(result200);

    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException("A server side error occurred.", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ItemResponseModelOfDevice>(null as any);
  }

  mQTTDevicePUT(aquarium: string | null, iD: string | null, mqtt: MQTTDevice, cancelToken?: CancelToken | undefined): Promise<ItemResponseModelOfDevice> {
    let url_ = this.baseUrl + "/data/Device/{Aquarium}/MQTTDevice/{ID}";
    if (aquarium === undefined || aquarium === null)
      throw new Error("The parameter 'aquarium' must be defined.");
    url_ = url_.replace("{Aquarium}", encodeURIComponent("" + aquarium));
    if (iD === undefined || iD === null)
      throw new Error("The parameter 'iD' must be defined.");
    url_ = url_.replace("{ID}", encodeURIComponent("" + iD));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(mqtt);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      cancelToken
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.instance.request(transformedOptions_);
    }).catch((_error: any) => {
      if (isAxiosError(_error) && _error.response) {
        return _error.response;
      } else {
        throw _error;
      }
    }).then((_response: AxiosResponse) => {
      return this.processMQTTDevicePUT(_response);
    });
  }

  protected processMQTTDevicePUT(response: AxiosResponse): Promise<ItemResponseModelOfDevice> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ItemResponseModelOfDevice.fromJS(resultData200);
      return Promise.resolve<ItemResponseModelOfDevice>(result200);

    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException("A server side error occurred.", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ItemResponseModelOfDevice>(null as any);
  }
}

export class ValueReturnModelBase implements IValueReturnModelBase {
  dataPoint!: DataPoint;

  constructor(data?: IValueReturnModelBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.dataPoint = new DataPoint();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dataPoint = _data["dataPoint"] ? DataPoint.fromJS(_data["dataPoint"]) : new DataPoint();
    }
  }

  static fromJS(data: any): ValueReturnModelBase {
    data = typeof data === 'object' ? data : {};
    let result = new ValueReturnModelBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dataPoint"] = this.dataPoint ? this.dataPoint.toJSON() : <any>undefined;
    return data;
  }
}

export interface IValueReturnModelBase {
  dataPoint: DataPoint;
}

export class ValueReturnModelSingle extends ValueReturnModelBase implements IValueReturnModelSingle {
  sample!: Sample;
  visuals!: VisualsReturnModel;

  constructor(data?: IValueReturnModelSingle) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.sample = _data["sample"] ? Sample.fromJS(_data["sample"]) : <any>undefined;
      this.visuals = _data["visuals"] ? VisualsReturnModel.fromJS(_data["visuals"]) : <any>undefined;
    }
  }

  static fromJS(data: any): ValueReturnModelSingle {
    data = typeof data === 'object' ? data : {};
    let result = new ValueReturnModelSingle();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["sample"] = this.sample ? this.sample.toJSON() : <any>undefined;
    data["visuals"] = this.visuals ? this.visuals.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IValueReturnModelSingle extends IValueReturnModelBase {
  sample: Sample;
  visuals: VisualsReturnModel;
}

export abstract class Sample implements ISample {
  tag!: string;
  timeStamp!: Date;
  value!: any;

  protected _discriminator: string;

  constructor(data?: ISample) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    this._discriminator = "Sample";
  }

  init(_data?: any) {
    if (_data) {
      this.tag = _data["tag"];
      this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): Sample {
    data = typeof data === 'object' ? data : {};
    if (data["discriminator"] === "BinarySample") {
      let result = new BinarySample();
      result.init(data);
      return result;
    }
    if (data["discriminator"] === "NumericSample") {
      let result = new NumericSample();
      result.init(data);
      return result;
    }
    throw new Error("The abstract class 'Sample' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["discriminator"] = this._discriminator;
    data["tag"] = this.tag;
    data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
    data["value"] = this.value;
    return data;
  }
}

export interface ISample {
  tag: string;
  timeStamp: Date;
  value: any;
}

export class BinarySample extends Sample implements IBinarySample {

  constructor(data?: IBinarySample) {
    super(data);
    this._discriminator = "BinarySample";
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): BinarySample {
    data = typeof data === 'object' ? data : {};
    let result = new BinarySample();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IBinarySample extends ISample {
}

export class NumericSample extends Sample implements INumericSample {

  constructor(data?: INumericSample) {
    super(data);
    this._discriminator = "NumericSample";
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): NumericSample {
    data = typeof data === 'object' ? data : {};
    let result = new NumericSample();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface INumericSample extends ISample {
}

export abstract class VisualsReturnModel implements IVisualsReturnModel {
  icon!: string;

  protected _discriminator: string;

  constructor(data?: IVisualsReturnModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    this._discriminator = "VisualsReturnModel";
  }

  init(_data?: any) {
    if (_data) {
      this.icon = _data["icon"];
    }
  }

  static fromJS(data: any): VisualsReturnModel {
    data = typeof data === 'object' ? data : {};
    if (data["discriminator"] === "VisualsNumericReturnModel") {
      let result = new VisualsNumericReturnModel();
      result.init(data);
      return result;
    }
    if (data["discriminator"] === "VisualsBinaryReturnModel") {
      let result = new VisualsBinaryReturnModel();
      result.init(data);
      return result;
    }
    throw new Error("The abstract class 'VisualsReturnModel' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["discriminator"] = this._discriminator;
    data["icon"] = this.icon;
    return data;
  }
}

export interface IVisualsReturnModel {
  icon: string;
}

export class VisualsNumericReturnModel extends VisualsReturnModel implements IVisualsNumericReturnModel {
  minValue!: number;
  maxValue!: number;
  unit!: string;

  constructor(data?: IVisualsNumericReturnModel) {
    super(data);
    this._discriminator = "VisualsNumericReturnModel";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.minValue = _data["minValue"];
      this.maxValue = _data["maxValue"];
      this.unit = _data["unit"];
    }
  }

  static fromJS(data: any): VisualsNumericReturnModel {
    data = typeof data === 'object' ? data : {};
    let result = new VisualsNumericReturnModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["minValue"] = this.minValue;
    data["maxValue"] = this.maxValue;
    data["unit"] = this.unit;
    super.toJSON(data);
    return data;
  }
}

export interface IVisualsNumericReturnModel extends IVisualsReturnModel {
  minValue: number;
  maxValue: number;
  unit: string;
}

export class VisualsBinaryReturnModel extends VisualsReturnModel implements IVisualsBinaryReturnModel {
  finalText!: string;

  constructor(data?: IVisualsBinaryReturnModel) {
    super(data);
    this._discriminator = "VisualsBinaryReturnModel";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.finalText = _data["finalText"];
    }
  }

  static fromJS(data: any): VisualsBinaryReturnModel {
    data = typeof data === 'object' ? data : {};
    let result = new VisualsBinaryReturnModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["finalText"] = this.finalText;
    super.toJSON(data);
    return data;
  }
}

export interface IVisualsBinaryReturnModel extends IVisualsReturnModel {
  finalText: string;
}

export abstract class Entity implements IEntity {
  id!: string;

  constructor(data?: IEntity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Entity {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'Entity' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    return data;
  }
}

export interface IEntity {
  id: string;
}

export class DataPoint extends Entity implements IDataPoint {
  name!: string;
  dataType!: DataType;
  offset!: number;
  description!: string;
  deviceName!: string;
  dataPointVisual!: string;

  protected _discriminator: string;

  constructor(data?: IDataPoint) {
    super(data);
    this._discriminator = "DataPoint";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.name = _data["name"];
      this.dataType = _data["dataType"];
      this.offset = _data["offset"];
      this.description = _data["description"];
      this.deviceName = _data["deviceName"];
      this.dataPointVisual = _data["dataPointVisual"];
    }
  }

  static fromJS(data: any): DataPoint {
    data = typeof data === 'object' ? data : {};
    if (data["discriminator"] === "ModbusDataPoint") {
      let result = new ModbusDataPoint();
      result.init(data);
      return result;
    }
    if (data["discriminator"] === "MQTTDataPoint") {
      let result = new MQTTDataPoint();
      result.init(data);
      return result;
    }
    let result = new DataPoint();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["discriminator"] = this._discriminator;
    data["name"] = this.name;
    data["dataType"] = this.dataType;
    data["offset"] = this.offset;
    data["description"] = this.description;
    data["deviceName"] = this.deviceName;
    data["dataPointVisual"] = this.dataPointVisual;
    super.toJSON(data);
    return data;
  }
}

export interface IDataPoint extends IEntity {
  name: string;
  dataType: DataType;
  offset: number;
  description: string;
  deviceName: string;
  dataPointVisual: string;
}

export enum DataType {
  Boolean = "Boolean",
  Float = "Float",
  Integer = "Integer",
}

export class ModbusDataPoint extends DataPoint implements IModbusDataPoint {
  registerType!: RegisterType;
  readingType!: ReadingType;
  register!: number;
  registerCount!: number;

  constructor(data?: IModbusDataPoint) {
    super(data);
    this._discriminator = "ModbusDataPoint";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.registerType = _data["registerType"];
      this.readingType = _data["readingType"];
      this.register = _data["register"];
      this.registerCount = _data["registerCount"];
    }
  }

  static fromJS(data: any): ModbusDataPoint {
    data = typeof data === 'object' ? data : {};
    let result = new ModbusDataPoint();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["registerType"] = this.registerType;
    data["readingType"] = this.readingType;
    data["register"] = this.register;
    data["registerCount"] = this.registerCount;
    super.toJSON(data);
    return data;
  }
}

export interface IModbusDataPoint extends IDataPoint {
  registerType: RegisterType;
  readingType: ReadingType;
  register: number;
  registerCount: number;
}

export enum RegisterType {
  InputRegister = "InputRegister",
  HoldingRegister = "HoldingRegister",
  Coil = "Coil",
  InputStatus = "InputStatus",
  WriteSingleCoil = "WriteSingleCoil",
  WriteSingleRegister = "WriteSingleRegister",
}

export enum ReadingType {
  LowToHigh = "LowToHigh",
  HighToLow = "HighToLow",
}

export class MQTTDataPoint extends DataPoint implements IMQTTDataPoint {
  topicName!: string;

  constructor(data?: IMQTTDataPoint) {
    super(data);
    this._discriminator = "MQTTDataPoint";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.topicName = _data["topicName"];
    }
  }

  static fromJS(data: any): MQTTDataPoint {
    data = typeof data === 'object' ? data : {};
    let result = new MQTTDataPoint();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["topicName"] = this.topicName;
    super.toJSON(data);
    return data;
  }
}

export interface IMQTTDataPoint extends IDataPoint {
  topicName: string;
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions!: { [key: string]: any; };

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.extensions = {};
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.title = _data["title"];
      this.status = _data["status"];
      this.detail = _data["detail"];
      this.instance = _data["instance"];
      if (_data["extensions"]) {
        this.extensions = {} as any;
        for (let key in _data["extensions"]) {
          if (_data["extensions"].hasOwnProperty(key))
            (<any>this.extensions)![key] = _data["extensions"][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["type"] = this.type;
    data["title"] = this.title;
    data["status"] = this.status;
    data["detail"] = this.detail;
    data["instance"] = this.instance;
    if (this.extensions) {
      data["extensions"] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          (<any>data["extensions"])[key] = this.extensions[key];
      }
    }
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions: { [key: string]: any; };
}

export class Device extends Entity implements IDevice {
  deviceType!: DeviceType;
  deviceName!: string;
  deviceDescription!: string;
  active!: boolean;
  aquarium!: string;

  protected _discriminator: string;

  constructor(data?: IDevice) {
    super(data);
    this._discriminator = "Device";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.deviceType = _data["deviceType"];
      this.deviceName = _data["deviceName"];
      this.deviceDescription = _data["deviceDescription"];
      this.active = _data["active"];
      this.aquarium = _data["aquarium"];
    }
  }

  static fromJS(data: any): Device {
    data = typeof data === 'object' ? data : {};
    if (data["discriminator"] === "ModbusDevice") {
      let result = new ModbusDevice();
      result.init(data);
      return result;
    }
    if (data["discriminator"] === "MQTTDevice") {
      let result = new MQTTDevice();
      result.init(data);
      return result;
    }
    let result = new Device();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["discriminator"] = this._discriminator;
    data["deviceType"] = this.deviceType;
    data["deviceName"] = this.deviceName;
    data["deviceDescription"] = this.deviceDescription;
    data["active"] = this.active;
    data["aquarium"] = this.aquarium;
    super.toJSON(data);
    return data;
  }
}

export interface IDevice extends IEntity {
  deviceType: DeviceType;
  deviceName: string;
  deviceDescription: string;
  active: boolean;
  aquarium: string;
}

export enum DeviceType {
  Pump = "Pump",
  Water = "Water",
}

export class ModbusDevice extends Device implements IModbusDevice {
  host!: string;
  port!: number;
  slaveID!: number;

  constructor(data?: IModbusDevice) {
    super(data);
    this._discriminator = "ModbusDevice";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.host = _data["host"];
      this.port = _data["port"];
      this.slaveID = _data["slaveID"];
    }
  }

  static fromJS(data: any): ModbusDevice {
    data = typeof data === 'object' ? data : {};
    let result = new ModbusDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["host"] = this.host;
    data["port"] = this.port;
    data["slaveID"] = this.slaveID;
    super.toJSON(data);
    return data;
  }
}

export interface IModbusDevice extends IDevice {
  host: string;
  port: number;
  slaveID: number;
}

export class MQTTDevice extends Device implements IMQTTDevice {
  host!: string;
  port!: number;

  constructor(data?: IMQTTDevice) {
    super(data);
    this._discriminator = "MQTTDevice";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.host = _data["host"];
      this.port = _data["port"];
    }
  }

  static fromJS(data: any): MQTTDevice {
    data = typeof data === 'object' ? data : {};
    let result = new MQTTDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["host"] = this.host;
    data["port"] = this.port;
    super.toJSON(data);
    return data;
  }
}

export interface IMQTTDevice extends IDevice {
  host: string;
  port: number;
}

export class ResponseModel implements IResponseModel {
  hasError!: boolean;
  errorMessages!: { [key: string]: string; };
  warningMessages!: { [key: string]: string; };
  hasWarning!: boolean;

  constructor(data?: IResponseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.errorMessages = {};
      this.warningMessages = {};
    }
  }

  init(_data?: any) {
    if (_data) {
      this.hasError = _data["hasError"];
      if (_data["errorMessages"]) {
        this.errorMessages = {} as any;
        for (let key in _data["errorMessages"]) {
          if (_data["errorMessages"].hasOwnProperty(key))
            (<any>this.errorMessages)![key] = _data["errorMessages"][key];
        }
      }
      if (_data["warningMessages"]) {
        this.warningMessages = {} as any;
        for (let key in _data["warningMessages"]) {
          if (_data["warningMessages"].hasOwnProperty(key))
            (<any>this.warningMessages)![key] = _data["warningMessages"][key];
        }
      }
      this.hasWarning = _data["hasWarning"];
    }
  }

  static fromJS(data: any): ResponseModel {
    data = typeof data === 'object' ? data : {};
    let result = new ResponseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["hasError"] = this.hasError;
    if (this.errorMessages) {
      data["errorMessages"] = {};
      for (let key in this.errorMessages) {
        if (this.errorMessages.hasOwnProperty(key))
          (<any>data["errorMessages"])[key] = this.errorMessages[key];
      }
    }
    if (this.warningMessages) {
      data["warningMessages"] = {};
      for (let key in this.warningMessages) {
        if (this.warningMessages.hasOwnProperty(key))
          (<any>data["warningMessages"])[key] = this.warningMessages[key];
      }
    }
    data["hasWarning"] = this.hasWarning;
    return data;
  }
}

export interface IResponseModel {
  hasError: boolean;
  errorMessages: { [key: string]: string; };
  warningMessages: { [key: string]: string; };
  hasWarning: boolean;
}

export class ItemResponseModelOfModbusDevice extends ResponseModel implements IItemResponseModelOfModbusDevice {
  data!: ModbusDevice;

  constructor(data?: IItemResponseModelOfModbusDevice) {
    super(data);
    if (!data) {
      this.data = new ModbusDevice();
    }
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.data = _data["data"] ? ModbusDevice.fromJS(_data["data"]) : new ModbusDevice();
    }
  }

  static fromJS(data: any): ItemResponseModelOfModbusDevice {
    data = typeof data === 'object' ? data : {};
    let result = new ItemResponseModelOfModbusDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IItemResponseModelOfModbusDevice extends IResponseModel {
  data: ModbusDevice;
}

export class ItemResponseModelOfMQTTDevice extends ResponseModel implements IItemResponseModelOfMQTTDevice {
  data!: MQTTDevice;

  constructor(data?: IItemResponseModelOfMQTTDevice) {
    super(data);
    if (!data) {
      this.data = new MQTTDevice();
    }
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.data = _data["data"] ? MQTTDevice.fromJS(_data["data"]) : new MQTTDevice();
    }
  }

  static fromJS(data: any): ItemResponseModelOfMQTTDevice {
    data = typeof data === 'object' ? data : {};
    let result = new ItemResponseModelOfMQTTDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IItemResponseModelOfMQTTDevice extends IResponseModel {
  data: MQTTDevice;
}

export class ItemResponseModelOfDevice extends ResponseModel implements IItemResponseModelOfDevice {
  data!: Device;

  constructor(data?: IItemResponseModelOfDevice) {
    super(data);
    if (!data) {
      this.data = new Device();
    }
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.data = _data["data"] ? Device.fromJS(_data["data"]) : new Device();
    }
  }

  static fromJS(data: any): ItemResponseModelOfDevice {
    data = typeof data === 'object' ? data : {};
    let result = new ItemResponseModelOfDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IItemResponseModelOfDevice extends IResponseModel {
  data: Device;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
  if (result !== null && result !== undefined)
    throw result;
  else
    throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}

